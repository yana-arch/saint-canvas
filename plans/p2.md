# ğŸš€ Káº¿ Hoáº¡ch TÃ­ch Há»£p Äa Ná»n Táº£ng AI - SaintCanvas

## ğŸ“‹ Tá»•ng Quan Má»Ÿ Rá»™ng

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         CURRENT STATE                                        â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚                    â”‚   Google GenAI      â”‚                                   â”‚
â”‚                    â”‚   (Gemini Models)   â”‚                                   â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         FUTURE STATE                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    AI Provider Abstraction Layer                      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚       â”‚            â”‚            â”‚            â”‚            â”‚                  â”‚
â”‚       â–¼            â–¼            â–¼            â–¼            â–¼                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚  â”‚ Google  â”‚ â”‚ OpenAI  â”‚ â”‚Stabilityâ”‚ â”‚Replicateâ”‚ â”‚ Together AI /   â”‚       â”‚
â”‚  â”‚ Gemini  â”‚ â”‚ DALL-E  â”‚ â”‚   AI    â”‚ â”‚  (Flux) â”‚ â”‚ Other Providers â”‚       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ¯ CÃ¡c Ná»n Táº£ng AI Äá» Xuáº¥t TÃ­ch Há»£p

| Provider | Model(s) | Æ¯u Äiá»ƒm | NhÆ°á»£c Äiá»ƒm | Pricing |
|----------|----------|---------|------------|---------|
| **Google Gemini** (Hiá»‡n cÃ³) | gemini-2.5-flash-image, gemini-3-pro | Nhanh, tÃ­ch há»£p sáºµn | Limited editing | Free tier cÃ³ |
| **OpenAI DALL-E** | DALL-E 3, DALL-E 2 | Cháº¥t lÆ°á»£ng cao, prompt hiá»ƒu tá»‘t | Äáº¯t hÆ¡n | $0.04-0.12/image |
| **Stability AI** | SDXL, SD 3.5, Stable Image Core | Nhiá»u options, inpainting tá»‘t | Cáº§n fine-tune | $0.01-0.06/image |
| **Replicate** | Flux, SDXL variants | Äa dáº¡ng models, pay-per-use | Latency cao hÆ¡n | Variable |
| **Together AI** | Flux Schnell, SDXL Lightning | Nhanh, giÃ¡ tá»‘t | Ãt features | $0.003-0.01/image |
| **Fal.ai** | Flux Pro, Recraft v3 | Ráº¥t nhanh, API Ä‘Æ¡n giáº£n | Má»›i, Ã­t documentation | Pay-per-use |
| **Leonardo AI** | Phoenix, Kino XL | Cháº¥t lÆ°á»£ng nghá»‡ thuáº­t cao | API háº¡n cháº¿ | Subscription |

---

## ğŸ“ Cáº¥u TrÃºc ThÆ° Má»¥c Má»›i

```
src/
â”œâ”€â”€ services/
â”‚   â””â”€â”€ ai/
â”‚       â”œâ”€â”€ index.ts                    # Export chung
â”‚       â”œâ”€â”€ types.ts                    # Shared types & interfaces
â”‚       â”œâ”€â”€ AIProviderManager.ts        # Manager class Ä‘iá»u phá»‘i
â”‚       â”œâ”€â”€ BaseProvider.ts             # Abstract base class
â”‚       â”‚
â”‚       â”œâ”€â”€ providers/
â”‚       â”‚   â”œâ”€â”€ GoogleGeminiProvider.ts
â”‚       â”‚   â”œâ”€â”€ OpenAIProvider.ts
â”‚       â”‚   â”œâ”€â”€ StabilityAIProvider.ts
â”‚       â”‚   â”œâ”€â”€ ReplicateProvider.ts
â”‚       â”‚   â”œâ”€â”€ TogetherAIProvider.ts
â”‚       â”‚   â”œâ”€â”€ FalAIProvider.ts
â”‚       â”‚   â””â”€â”€ index.ts
â”‚       â”‚
â”‚       â”œâ”€â”€ utils/
â”‚       â”‚   â”œâ”€â”€ imageProcessing.ts      # Resize, format conversion
â”‚       â”‚   â”œâ”€â”€ promptEnhancer.ts       # Enhance prompts cho Catholic theme
â”‚       â”‚   â””â”€â”€ rateLimiter.ts          # Rate limiting & quota
â”‚       â”‚
â”‚       â””â”€â”€ presets/
â”‚           â”œâ”€â”€ catholicStyles.ts       # Art style presets
â”‚           â””â”€â”€ modelConfigs.ts         # Default configs per model
â”‚
â”œâ”€â”€ components/
â”‚   â””â”€â”€ AI/
â”‚       â”œâ”€â”€ PromptPanel.tsx             # Updated with provider selection
â”‚       â”œâ”€â”€ ProviderSelector.tsx        # New: Dropdown/tabs for providers
â”‚       â”œâ”€â”€ ModelSettings.tsx           # New: Per-model settings
â”‚       â”œâ”€â”€ APIKeyManager.tsx           # New: Manage API keys
â”‚       â”œâ”€â”€ GenerationHistory.tsx       # New: History of generations
â”‚       â””â”€â”€ CostEstimator.tsx           # New: Estimate cost before generate
â”‚
â”œâ”€â”€ store/
â”‚   â””â”€â”€ aiStore.ts                      # New: AI-specific state
â”‚
â””â”€â”€ hooks/
    â”œâ”€â”€ useAIGeneration.ts              # Unified hook for generation
    â””â”€â”€ useProviderStatus.ts            # Check provider availability
```

---

## ğŸ”§ Core Implementation

### 1ï¸âƒ£ **Types & Interfaces**

```typescript
// services/ai/types.ts

export type AIProviderType = 
  | 'google-gemini'
  | 'openai-dalle'
  | 'stability-ai'
  | 'replicate'
  | 'together-ai'
  | 'fal-ai'
  | 'leonardo-ai';

export type GenerationMode = 'text-to-image' | 'image-to-image' | 'inpainting' | 'outpainting';

export type ImageSize = '512x512' | '768x768' | '1024x1024' | '1024x1792' | '1792x1024';

export interface AIProviderConfig {
  id: AIProviderType;
  name: string;
  description: string;
  icon: string;
  supportedModes: GenerationMode[];
  supportedSizes: ImageSize[];
  models: AIModel[];
  requiresApiKey: boolean;
  pricingInfo?: PricingInfo;
  rateLimit?: RateLimitConfig;
}

export interface AIModel {
  id: string;
  name: string;
  description?: string;
  capabilities: GenerationMode[];
  defaultSize: ImageSize;
  maxImages: number;
  estimatedTime: number; // seconds
  costPerImage?: number; // USD
}

export interface GenerationRequest {
  provider: AIProviderType;
  model: string;
  mode: GenerationMode;
  prompt: string;
  negativePrompt?: string;
  
  // Image dimensions
  width?: number;
  height?: number;
  aspectRatio?: string;
  
  // For image-to-image / editing
  sourceImage?: string; // base64
  maskImage?: string;   // base64 for inpainting
  strength?: number;    // 0-1, how much to transform
  
  // Generation params
  numImages?: number;
  seed?: number;
  guidanceScale?: number;
  steps?: number;
  
  // Style
  style?: CatholicArtStyle;
  styleStrength?: number;
  
  // Advanced
  scheduler?: string;
  sampler?: string;
}

export interface GenerationResponse {
  success: boolean;
  provider: AIProviderType;
  model: string;
  images: GeneratedImage[];
  metadata: GenerationMetadata;
  error?: GenerationError;
}

export interface GeneratedImage {
  id: string;
  url?: string;          // Remote URL
  base64?: string;       // Base64 data
  width: number;
  height: number;
  seed?: number;
  revisedPrompt?: string; // Some providers revise prompts
}

export interface GenerationMetadata {
  requestId: string;
  timestamp: number;
  duration: number;      // ms
  cost?: number;         // USD
  tokensUsed?: number;
  remainingCredits?: number;
}

export interface GenerationError {
  code: string;
  message: string;
  retryable: boolean;
  retryAfter?: number;   // seconds
}

export type CatholicArtStyle = 
  | 'byzantine'
  | 'renaissance'
  | 'baroque'
  | 'stained-glass'
  | 'icon'
  | 'medieval'
  | 'classical'
  | 'modern-sacred'
  | 'watercolor'
  | 'oil-painting';

export interface PricingInfo {
  currency: 'USD';
  pricePerImage: number;
  freeCredits?: number;
  billingUrl?: string;
}

export interface RateLimitConfig {
  requestsPerMinute: number;
  requestsPerDay?: number;
  imagesPerRequest: number;
}

export interface ProviderCredentials {
  provider: AIProviderType;
  apiKey: string;
  organizationId?: string;  // For OpenAI
  projectId?: string;       // For Google
}
```

### 2ï¸âƒ£ **Base Provider Abstract Class**

```typescript
// services/ai/BaseProvider.ts

import {
  AIProviderType,
  AIProviderConfig,
  GenerationRequest,
  GenerationResponse,
  GeneratedImage,
  GenerationMode,
} from './types';

export abstract class BaseAIProvider {
  protected apiKey: string | null = null;
  protected config: AIProviderConfig;
  
  constructor(config: AIProviderConfig) {
    this.config = config;
  }

  // Abstract methods - must implement
  abstract generate(request: GenerationRequest): Promise<GenerationResponse>;
  abstract validateApiKey(apiKey: string): Promise<boolean>;
  abstract getAvailableModels(): Promise<string[]>;
  
  // Optional overrides
  async editImage(request: GenerationRequest): Promise<GenerationResponse> {
    throw new Error(`${this.config.name} does not support image editing`);
  }
  
  async inpaint(request: GenerationRequest): Promise<GenerationResponse> {
    throw new Error(`${this.config.name} does not support inpainting`);
  }

  // Common methods
  setApiKey(apiKey: string): void {
    this.apiKey = apiKey;
  }

  getConfig(): AIProviderConfig {
    return this.config;
  }

  isConfigured(): boolean {
    return !this.config.requiresApiKey || !!this.apiKey;
  }

  supportsMode(mode: GenerationMode): boolean {
    return this.config.supportedModes.includes(mode);
  }

  estimateCost(request: GenerationRequest): number {
    const model = this.config.models.find(m => m.id === request.model);
    if (!model?.costPerImage) return 0;
    return model.costPerImage * (request.numImages || 1);
  }

  // Enhance prompt with Catholic context
  protected enhancePrompt(prompt: string, style?: string): string {
    const baseEnhancement = 'sacred, religious, Catholic, holy, divine light';
    const styleMap: Record<string, string> = {
      'byzantine': 'Byzantine icon style, gold leaf, flat perspective, halo, sacred geometry',
      'renaissance': 'Renaissance masterpiece, oil painting, chiaroscuro, classical composition',
      'baroque': 'Baroque style, dramatic lighting, dynamic composition, rich colors',
      'stained-glass': 'stained glass window style, vibrant colors, lead lines, luminous',
      'icon': 'Eastern Orthodox icon, egg tempera, gold background, stylized features',
      'medieval': 'Medieval illuminated manuscript, ornate borders, gold accents',
    };
    
    const stylePrompt = style && styleMap[style] ? `, ${styleMap[style]}` : '';
    return `${prompt}, ${baseEnhancement}${stylePrompt}`;
  }

  // Convert base64 to appropriate format
  protected async prepareImage(base64: string): Promise<string> {
    // Remove data URL prefix if present
    const base64Data = base64.replace(/^data:image\/\w+;base64,/, '');
    return base64Data;
  }

  // Create standard response
  protected createResponse(
    images: GeneratedImage[],
    duration: number,
    request: GenerationRequest
  ): GenerationResponse {
    return {
      success: true,
      provider: this.config.id,
      model: request.model,
      images,
      metadata: {
        requestId: crypto.randomUUID(),
        timestamp: Date.now(),
        duration,
        cost: this.estimateCost(request),
      },
    };
  }

  // Create error response
  protected createErrorResponse(
    error: Error,
    request: GenerationRequest
  ): GenerationResponse {
    return {
      success: false,
      provider: this.config.id,
      model: request.model,
      images: [],
      metadata: {
        requestId: crypto.randomUUID(),
        timestamp: Date.now(),
        duration: 0,
      },
      error: {
        code: 'GENERATION_FAILED',
        message: error.message,
        retryable: this.isRetryableError(error),
      },
    };
  }

  protected isRetryableError(error: Error): boolean {
    const retryablePatterns = [
      'rate limit',
      'timeout',
      'temporarily unavailable',
      '503',
      '429',
    ];
    return retryablePatterns.some(pattern => 
      error.message.toLowerCase().includes(pattern)
    );
  }
}
```

### 3ï¸âƒ£ **Provider Implementations**

#### Google Gemini (Existing - Refactored)

```typescript
// services/ai/providers/GoogleGeminiProvider.ts

import { GoogleGenAI, Modality } from '@google/genai';
import { BaseAIProvider } from '../BaseProvider';
import {
  AIProviderConfig,
  GenerationRequest,
  GenerationResponse,
  GeneratedImage,
} from '../types';

const GEMINI_CONFIG: AIProviderConfig = {
  id: 'google-gemini',
  name: 'Google Gemini',
  description: 'Google\'s multimodal AI models with image generation',
  icon: 'gemini',
  supportedModes: ['text-to-image', 'image-to-image'],
  supportedSizes: ['512x512', '1024x1024'],
  models: [
    {
      id: 'gemini-2.0-flash-exp-image-generation',
      name: 'Gemini 2.0 Flash (Image)',
      capabilities: ['text-to-image', 'image-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 15,
    },
    {
      id: 'imagen-3.0-generate-002',
      name: 'Imagen 3',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 10,
      costPerImage: 0.02,
    },
  ],
  requiresApiKey: true,
  rateLimit: {
    requestsPerMinute: 10,
    imagesPerRequest: 4,
  },
};

export class GoogleGeminiProvider extends BaseAIProvider {
  private client: GoogleGenAI | null = null;

  constructor() {
    super(GEMINI_CONFIG);
  }

  setApiKey(apiKey: string): void {
    super.setApiKey(apiKey);
    this.client = new GoogleGenAI({ apiKey });
  }

  async validateApiKey(apiKey: string): Promise<boolean> {
    try {
      const testClient = new GoogleGenAI({ apiKey });
      // Make a minimal request to validate
      await testClient.models.list();
      return true;
    } catch {
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    return this.config.models.map(m => m.id);
  }

  async generate(request: GenerationRequest): Promise<GenerationResponse> {
    if (!this.client) {
      throw new Error('API key not configured');
    }

    const startTime = Date.now();

    try {
      const enhancedPrompt = this.enhancePrompt(request.prompt, request.style);
      
      // Determine if using Gemini or Imagen
      if (request.model.includes('imagen')) {
        return await this.generateWithImagen(request, enhancedPrompt, startTime);
      }
      
      return await this.generateWithGemini(request, enhancedPrompt, startTime);
    } catch (error) {
      return this.createErrorResponse(error as Error, request);
    }
  }

  private async generateWithGemini(
    request: GenerationRequest,
    prompt: string,
    startTime: number
  ): Promise<GenerationResponse> {
    const contents = request.sourceImage
      ? [
          { text: prompt },
          {
            inlineData: {
              mimeType: 'image/png',
              data: await this.prepareImage(request.sourceImage),
            },
          },
        ]
      : prompt;

    const response = await this.client!.models.generateContent({
      model: request.model,
      contents,
      config: {
        responseModalities: [Modality.TEXT, Modality.IMAGE],
      },
    });

    const images: GeneratedImage[] = [];
    
    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        images.push({
          id: crypto.randomUUID(),
          base64: `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`,
          width: request.width || 1024,
          height: request.height || 1024,
        });
      }
    }

    return this.createResponse(images, Date.now() - startTime, request);
  }

  private async generateWithImagen(
    request: GenerationRequest,
    prompt: string,
    startTime: number
  ): Promise<GenerationResponse> {
    const response = await this.client!.models.generateImages({
      model: request.model,
      prompt,
      config: {
        numberOfImages: request.numImages || 1,
        aspectRatio: request.aspectRatio || '1:1',
      },
    });

    const images: GeneratedImage[] = (response.generatedImages || []).map(
      (img) => ({
        id: crypto.randomUUID(),
        base64: `data:image/png;base64,${img.image?.imageBytes}`,
        width: request.width || 1024,
        height: request.height || 1024,
      })
    );

    return this.createResponse(images, Date.now() - startTime, request);
  }

  async editImage(request: GenerationRequest): Promise<GenerationResponse> {
    // Gemini supports image editing through multimodal input
    if (!request.sourceImage) {
      throw new Error('Source image required for editing');
    }
    return this.generate(request);
  }
}

export default GoogleGeminiProvider;
```

#### OpenAI DALL-E Provider

```typescript
// services/ai/providers/OpenAIProvider.ts

import { BaseAIProvider } from '../BaseProvider';
import {
  AIProviderConfig,
  GenerationRequest,
  GenerationResponse,
  GeneratedImage,
} from '../types';

const OPENAI_CONFIG: AIProviderConfig = {
  id: 'openai-dalle',
  name: 'OpenAI DALL-E',
  description: 'State-of-the-art image generation from OpenAI',
  icon: 'openai',
  supportedModes: ['text-to-image', 'image-to-image', 'inpainting'],
  supportedSizes: ['1024x1024', '1024x1792', '1792x1024'],
  models: [
    {
      id: 'dall-e-3',
      name: 'DALL-E 3',
      description: 'Latest model with best quality',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 1,
      estimatedTime: 20,
      costPerImage: 0.04,
    },
    {
      id: 'dall-e-2',
      name: 'DALL-E 2',
      description: 'Supports editing and variations',
      capabilities: ['text-to-image', 'image-to-image', 'inpainting'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 15,
      costPerImage: 0.02,
    },
    {
      id: 'gpt-image-1',
      name: 'GPT Image 1',
      description: 'New GPT-4o native image generation',
      capabilities: ['text-to-image', 'image-to-image'],
      defaultSize: '1024x1024',
      maxImages: 1,
      estimatedTime: 25,
      costPerImage: 0.08,
    },
  ],
  requiresApiKey: true,
  pricingInfo: {
    currency: 'USD',
    pricePerImage: 0.04,
    billingUrl: 'https://platform.openai.com/usage',
  },
  rateLimit: {
    requestsPerMinute: 5,
    imagesPerRequest: 4,
  },
};

export class OpenAIProvider extends BaseAIProvider {
  private baseUrl = 'https://api.openai.com/v1';

  constructor() {
    super(OPENAI_CONFIG);
  }

  async validateApiKey(apiKey: string): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/models`, {
        headers: { Authorization: `Bearer ${apiKey}` },
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    return this.config.models.map(m => m.id);
  }

  async generate(request: GenerationRequest): Promise<GenerationResponse> {
    if (!this.apiKey) {
      throw new Error('OpenAI API key not configured');
    }

    const startTime = Date.now();

    try {
      const enhancedPrompt = this.enhancePrompt(request.prompt, request.style);
      
      // Use GPT-4o for gpt-image-1
      if (request.model === 'gpt-image-1') {
        return await this.generateWithGPT4o(request, enhancedPrompt, startTime);
      }

      // Standard DALL-E generation
      const response = await fetch(`${this.baseUrl}/images/generations`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: request.model,
          prompt: enhancedPrompt,
          n: request.model === 'dall-e-3' ? 1 : (request.numImages || 1),
          size: this.mapSize(request.width, request.height),
          quality: 'hd',
          style: 'vivid',
          response_format: 'b64_json',
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || 'Generation failed');
      }

      const data = await response.json();
      
      const images: GeneratedImage[] = data.data.map((img: any) => ({
        id: crypto.randomUUID(),
        base64: `data:image/png;base64,${img.b64_json}`,
        width: request.width || 1024,
        height: request.height || 1024,
        revisedPrompt: img.revised_prompt,
      }));

      return this.createResponse(images, Date.now() - startTime, request);
    } catch (error) {
      return this.createErrorResponse(error as Error, request);
    }
  }

  private async generateWithGPT4o(
    request: GenerationRequest,
    prompt: string,
    startTime: number
  ): Promise<GenerationResponse> {
    const messages: any[] = [
      {
        role: 'user',
        content: request.sourceImage
          ? [
              { type: 'text', text: prompt },
              {
                type: 'image_url',
                image_url: { url: request.sourceImage },
              },
            ]
          : prompt,
      },
    ];

    const response = await fetch(`${this.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages,
        modalities: ['text', 'image'],
        max_tokens: 4096,
      }),
    });

    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.error?.message || 'GPT-4o generation failed');
    }

    const data = await response.json();
    const images: GeneratedImage[] = [];

    for (const choice of data.choices || []) {
      for (const part of choice.message?.content || []) {
        if (part.type === 'image_url') {
          images.push({
            id: crypto.randomUUID(),
            base64: part.image_url.url,
            width: request.width || 1024,
            height: request.height || 1024,
          });
        }
      }
    }

    return this.createResponse(images, Date.now() - startTime, request);
  }

  async editImage(request: GenerationRequest): Promise<GenerationResponse> {
    if (!this.apiKey || !request.sourceImage) {
      throw new Error('API key and source image required');
    }

    const startTime = Date.now();

    try {
      // Convert base64 to blob
      const imageBlob = await this.base64ToBlob(request.sourceImage);
      
      const formData = new FormData();
      formData.append('image', imageBlob, 'image.png');
      formData.append('prompt', this.enhancePrompt(request.prompt, request.style));
      formData.append('n', String(request.numImages || 1));
      formData.append('size', this.mapSize(request.width, request.height));
      formData.append('response_format', 'b64_json');

      if (request.maskImage) {
        const maskBlob = await this.base64ToBlob(request.maskImage);
        formData.append('mask', maskBlob, 'mask.png');
      }

      const response = await fetch(`${this.baseUrl}/images/edits`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
        },
        body: formData,
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || 'Edit failed');
      }

      const data = await response.json();
      
      const images: GeneratedImage[] = data.data.map((img: any) => ({
        id: crypto.randomUUID(),
        base64: `data:image/png;base64,${img.b64_json}`,
        width: request.width || 1024,
        height: request.height || 1024,
      }));

      return this.createResponse(images, Date.now() - startTime, request);
    } catch (error) {
      return this.createErrorResponse(error as Error, request);
    }
  }

  async inpaint(request: GenerationRequest): Promise<GenerationResponse> {
    return this.editImage(request);
  }

  private mapSize(width?: number, height?: number): string {
    if (!width || !height) return '1024x1024';
    
    const ratio = width / height;
    if (ratio > 1.5) return '1792x1024';
    if (ratio < 0.67) return '1024x1792';
    return '1024x1024';
  }

  private async base64ToBlob(base64: string): Promise<Blob> {
    const response = await fetch(base64);
    return response.blob();
  }
}

export default OpenAIProvider;
```

#### Stability AI Provider

```typescript
// services/ai/providers/StabilityAIProvider.ts

import { BaseAIProvider } from '../BaseProvider';
import {
  AIProviderConfig,
  GenerationRequest,
  GenerationResponse,
  GeneratedImage,
} from '../types';

const STABILITY_CONFIG: AIProviderConfig = {
  id: 'stability-ai',
  name: 'Stability AI',
  description: 'Stable Diffusion and advanced image models',
  icon: 'stability',
  supportedModes: ['text-to-image', 'image-to-image', 'inpainting', 'outpainting'],
  supportedSizes: ['512x512', '768x768', '1024x1024'],
  models: [
    {
      id: 'sd3.5-large',
      name: 'Stable Diffusion 3.5 Large',
      capabilities: ['text-to-image', 'image-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 10,
      costPerImage: 0.065,
    },
    {
      id: 'sd3.5-large-turbo',
      name: 'SD 3.5 Large Turbo',
      description: 'Faster generation, slightly lower quality',
      capabilities: ['text-to-image', 'image-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 5,
      costPerImage: 0.04,
    },
    {
      id: 'stable-image-core',
      name: 'Stable Image Core',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 8,
      costPerImage: 0.03,
    },
    {
      id: 'stable-image-ultra',
      name: 'Stable Image Ultra',
      description: 'Highest quality, photorealistic',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 1,
      estimatedTime: 15,
      costPerImage: 0.08,
    },
  ],
  requiresApiKey: true,
  pricingInfo: {
    currency: 'USD',
    pricePerImage: 0.04,
    billingUrl: 'https://platform.stability.ai/account/credits',
  },
  rateLimit: {
    requestsPerMinute: 10,
    imagesPerRequest: 4,
  },
};

export class StabilityAIProvider extends BaseAIProvider {
  private baseUrl = 'https://api.stability.ai/v2beta';

  constructor() {
    super(STABILITY_CONFIG);
  }

  async validateApiKey(apiKey: string): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/user/account`, {
        headers: { Authorization: `Bearer ${apiKey}` },
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    return this.config.models.map(m => m.id);
  }

  async generate(request: GenerationRequest): Promise<GenerationResponse> {
    if (!this.apiKey) {
      throw new Error('Stability AI API key not configured');
    }

    const startTime = Date.now();

    try {
      const enhancedPrompt = this.enhancePrompt(request.prompt, request.style);
      
      // Different endpoints for different models
      const endpoint = this.getEndpoint(request.model);
      
      const formData = new FormData();
      formData.append('prompt', enhancedPrompt);
      
      if (request.negativePrompt) {
        formData.append('negative_prompt', request.negativePrompt);
      }
      
      formData.append('output_format', 'png');
      
      // Model-specific params
      if (request.model.includes('sd3')) {
        formData.append('model', request.model);
        if (request.aspectRatio) {
          formData.append('aspect_ratio', request.aspectRatio);
        }
      }

      if (request.seed) {
        formData.append('seed', String(request.seed));
      }

      // For image-to-image
      if (request.sourceImage && request.mode === 'image-to-image') {
        const imageBlob = await this.base64ToBlob(request.sourceImage);
        formData.append('image', imageBlob);
        formData.append('strength', String(request.strength || 0.7));
      }

      const response = await fetch(`${this.baseUrl}/${endpoint}`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.apiKey}`,
          Accept: 'image/*',
        },
        body: formData,
      });

      if (!response.ok) {
        const error = await response.json().catch(() => ({ message: 'Generation failed' }));
        throw new Error(error.message || 'Stability AI generation failed');
      }

      // Response is binary image data
      const imageBuffer = await response.arrayBuffer();
      const base64 = this.arrayBufferToBase64(imageBuffer);
      
      const images: GeneratedImage[] = [{
        id: crypto.randomUUID(),
        base64: `data:image/png;base64,${base64}`,
        width: request.width || 1024,
        height: request.height || 1024,
        seed: parseInt(response.headers.get('seed') || '0'),
      }];

      return this.createResponse(images, Date.now() - startTime, request);
    } catch (error) {
      return this.createErrorResponse(error as Error, request);
    }
  }

  async editImage(request: GenerationRequest): Promise<GenerationResponse> {
    return this.generate({ ...request, mode: 'image-to-image' });
  }

  async inpaint(request: GenerationRequest): Promise<GenerationResponse> {
    if (!this.apiKey || !request.sourceImage || !request.maskImage) {
      throw new Error('API key, source image, and mask required for inpainting');
    }

    const startTime = Date.now();

    try {
      const formData = new FormData();
      formData.append('prompt', this.enhancePrompt(request.prompt, request.style));
      
      const imageBlob = await this.base64ToBlob(request.sourceImage);
      const maskBlob = await this.base64ToBlob(request.maskImage);
      
      formData.append('image', imageBlob);
      formData.append('mask', maskBlob);
      formData.append('output_format', 'png');

      const response = await fetch(`${this.baseUrl}/stable-image/edit/inpaint`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.apiKey}`,
          Accept: 'image/*',
        },
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Inpainting failed');
      }

      const imageBuffer = await response.arrayBuffer();
      const base64 = this.arrayBufferToBase64(imageBuffer);
      
      const images: GeneratedImage[] = [{
        id: crypto.randomUUID(),
        base64: `data:image/png;base64,${base64}`,
        width: request.width || 1024,
        height: request.height || 1024,
      }];

      return this.createResponse(images, Date.now() - startTime, request);
    } catch (error) {
      return this.createErrorResponse(error as Error, request);
    }
  }

  private getEndpoint(model: string): string {
    if (model.includes('sd3')) {
      return 'stable-image/generate/sd3';
    }
    if (model === 'stable-image-ultra') {
      return 'stable-image/generate/ultra';
    }
    return 'stable-image/generate/core';
  }

  private async base64ToBlob(base64: string): Promise<Blob> {
    const response = await fetch(base64);
    return response.blob();
  }

  private arrayBufferToBase64(buffer: ArrayBuffer): string {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }
}

export default StabilityAIProvider;
```

#### Replicate Provider (Flux & More)

```typescript
// services/ai/providers/ReplicateProvider.ts

import { BaseAIProvider } from '../BaseProvider';
import {
  AIProviderConfig,
  GenerationRequest,
  GenerationResponse,
  GeneratedImage,
} from '../types';

const REPLICATE_CONFIG: AIProviderConfig = {
  id: 'replicate',
  name: 'Replicate',
  description: 'Access to Flux, SDXL, and many open-source models',
  icon: 'replicate',
  supportedModes: ['text-to-image', 'image-to-image'],
  supportedSizes: ['512x512', '768x768', '1024x1024', '1024x1792', '1792x1024'],
  models: [
    {
      id: 'black-forest-labs/flux-1.1-pro',
      name: 'Flux 1.1 Pro',
      description: 'Latest Flux model, excellent quality',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 15,
      costPerImage: 0.04,
    },
    {
      id: 'black-forest-labs/flux-schnell',
      name: 'Flux Schnell',
      description: 'Fast generation, good quality',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 5,
      costPerImage: 0.003,
    },
    {
      id: 'black-forest-labs/flux-dev',
      name: 'Flux Dev',
      description: 'Development model, high customization',
      capabilities: ['text-to-image', 'image-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 20,
      costPerImage: 0.025,
    },
    {
      id: 'stability-ai/sdxl',
      name: 'SDXL',
      capabilities: ['text-to-image', 'image-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 10,
      costPerImage: 0.01,
    },
  ],
  requiresApiKey: true,
  pricingInfo: {
    currency: 'USD',
    pricePerImage: 0.01,
    billingUrl: 'https://replicate.com/account/billing',
  },
  rateLimit: {
    requestsPerMinute: 60,
    imagesPerRequest: 4,
  },
};

export class ReplicateProvider extends BaseAIProvider {
  private baseUrl = 'https://api.replicate.com/v1';

  constructor() {
    super(REPLICATE_CONFIG);
  }

  async validateApiKey(apiKey: string): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/account`, {
        headers: { Authorization: `Bearer ${apiKey}` },
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    return this.config.models.map(m => m.id);
  }

  async generate(request: GenerationRequest): Promise<GenerationResponse> {
    if (!this.apiKey) {
      throw new Error('Replicate API key not configured');
    }

    const startTime = Date.now();

    try {
      const enhancedPrompt = this.enhancePrompt(request.prompt, request.style);
      
      // Build input based on model
      const input = this.buildInput(request, enhancedPrompt);

      // Create prediction
      const createResponse = await fetch(`${this.baseUrl}/models/${request.model}/predictions`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ input }),
      });

      if (!createResponse.ok) {
        const error = await createResponse.json();
        throw new Error(error.detail || 'Failed to create prediction');
      }

      const prediction = await createResponse.json();
      
      // Poll for result
      const result = await this.pollPrediction(prediction.id);
      
      if (result.status === 'failed') {
        throw new Error(result.error || 'Generation failed');
      }

      const images: GeneratedImage[] = this.parseOutput(result.output, request);

      return this.createResponse(images, Date.now() - startTime, request);
    } catch (error) {
      return this.createErrorResponse(error as Error, request);
    }
  }

  private buildInput(request: GenerationRequest, prompt: string): Record<string, any> {
    const baseInput: Record<string, any> = {
      prompt,
    };

    if (request.model.includes('flux')) {
      baseInput.num_outputs = request.numImages || 1;
      baseInput.aspect_ratio = this.mapAspectRatio(request.width, request.height);
      baseInput.output_format = 'png';
      baseInput.output_quality = 100;
      
      if (request.seed) {
        baseInput.seed = request.seed;
      }
      
      if (request.guidanceScale) {
        baseInput.guidance = request.guidanceScale;
      }

      // Flux Dev supports image input
      if (request.sourceImage && request.model.includes('dev')) {
        baseInput.image = request.sourceImage;
        baseInput.prompt_strength = request.strength || 0.8;
      }
    }

    if (request.model.includes('sdxl')) {
      baseInput.width = request.width || 1024;
      baseInput.height = request.height || 1024;
      baseInput.num_outputs = request.numImages || 1;
      baseInput.scheduler = request.scheduler || 'DPMSolverMultistep';
      baseInput.num_inference_steps = request.steps || 25;
      baseInput.guidance_scale = request.guidanceScale || 7.5;
      
      if (request.negativePrompt) {
        baseInput.negative_prompt = request.negativePrompt;
      }
      
      if (request.sourceImage) {
        baseInput.image = request.sourceImage;
        baseInput.prompt_strength = request.strength || 0.8;
      }
    }

    return baseInput;
  }

  private async pollPrediction(id: string, maxAttempts = 60): Promise<any> {
    for (let i = 0; i < maxAttempts; i++) {
      const response = await fetch(`${this.baseUrl}/predictions/${id}`, {
        headers: { Authorization: `Bearer ${this.apiKey}` },
      });

      const prediction = await response.json();

      if (prediction.status === 'succeeded' || prediction.status === 'failed') {
        return prediction;
      }

      // Wait 1 second before polling again
      await new Promise(resolve => setTimeout(resolve, 1000));
    }

    throw new Error('Prediction timeout');
  }

  private parseOutput(output: any, request: GenerationRequest): GeneratedImage[] {
    const outputs = Array.isArray(output) ? output : [output];
    
    return outputs.map((url: string) => ({
      id: crypto.randomUUID(),
      url, // Replicate returns URLs
      width: request.width || 1024,
      height: request.height || 1024,
    }));
  }

  private mapAspectRatio(width?: number, height?: number): string {
    if (!width || !height) return '1:1';
    
    const ratio = width / height;
    if (ratio > 1.7) return '16:9';
    if (ratio > 1.4) return '3:2';
    if (ratio > 1.2) return '4:3';
    if (ratio < 0.6) return '9:16';
    if (ratio < 0.75) return '2:3';
    if (ratio < 0.85) return '3:4';
    return '1:1';
  }
}

export default ReplicateProvider;
```

#### Together AI Provider

```typescript
// services/ai/providers/TogetherAIProvider.ts

import { BaseAIProvider } from '../BaseProvider';
import {
  AIProviderConfig,
  GenerationRequest,
  GenerationResponse,
  GeneratedImage,
} from '../types';

const TOGETHER_CONFIG: AIProviderConfig = {
  id: 'together-ai',
  name: 'Together AI',
  description: 'Fast and affordable image generation',
  icon: 'together',
  supportedModes: ['text-to-image'],
  supportedSizes: ['512x512', '768x768', '1024x1024'],
  models: [
    {
      id: 'black-forest-labs/FLUX.1-schnell-Free',
      name: 'Flux Schnell (Free)',
      description: 'Free tier, fast generation',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 5,
      costPerImage: 0,
    },
    {
      id: 'black-forest-labs/FLUX.1.1-pro',
      name: 'Flux 1.1 Pro',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 10,
      costPerImage: 0.04,
    },
    {
      id: 'stabilityai/stable-diffusion-xl-base-1.0',
      name: 'SDXL Base',
      capabilities: ['text-to-image'],
      defaultSize: '1024x1024',
      maxImages: 4,
      estimatedTime: 8,
      costPerImage: 0.006,
    },
  ],
  requiresApiKey: true,
  pricingInfo: {
    currency: 'USD',
    pricePerImage: 0.003,
    freeCredits: 25,
    billingUrl: 'https://api.together.xyz/settings/billing',
  },
  rateLimit: {
    requestsPerMinute: 60,
    imagesPerRequest: 4,
  },
};

export class TogetherAIProvider extends BaseAIProvider {
  private baseUrl = 'https://api.together.xyz/v1';

  constructor() {
    super(TOGETHER_CONFIG);
  }

  async validateApiKey(apiKey: string): Promise<boolean> {
    try {
      const response = await fetch(`${this.baseUrl}/models`, {
        headers: { Authorization: `Bearer ${apiKey}` },
      });
      return response.ok;
    } catch {
      return false;
    }
  }

  async getAvailableModels(): Promise<string[]> {
    return this.config.models.map(m => m.id);
  }

  async generate(request: GenerationRequest): Promise<GenerationResponse> {
    if (!this.apiKey) {
      throw new Error('Together AI API key not configured');
    }

    const startTime = Date.now();

    try {
      const enhancedPrompt = this.enhancePrompt(request.prompt, request.style);
      
      const response = await fetch(`${this.baseUrl}/images/generations`, {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: request.model,
          prompt: enhancedPrompt,
          width: request.width || 1024,
          height: request.height || 1024,
          n: request.numImages || 1,
          steps: request.steps || 20,
          seed: request.seed,
          negative_prompt: request.negativePrompt,
          response_format: 'b64_json',
        }),
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || 'Generation failed');
      }

      const data = await response.json();
      
      const images: GeneratedImage[] = data.data.map((img: any) => ({
        id: crypto.randomUUID(),
        base64: `data:image/png;base64,${img.b64_json}`,
        width: request.width || 1024,
        height: request.height || 1024,
        seed: img.seed,
      }));

      return this.createResponse(images, Date.now() - startTime, request);
    } catch (error) {
      return this.createErrorResponse(error as Error, request);
    }
  }
}

export default TogetherAIProvider;
```

### 4ï¸âƒ£ **AI Provider Manager**

```typescript
// services/ai/AIProviderManager.ts

import {
  AIProviderType,
  AIProviderConfig,
  GenerationRequest,
  GenerationResponse,
  ProviderCredentials,
} from './types';
import { BaseAIProvider } from './BaseProvider';

// Import all providers
import { GoogleGeminiProvider } from './providers/GoogleGeminiProvider';
import { OpenAIProvider } from './providers/OpenAIProvider';
import { StabilityAIProvider } from './providers/StabilityAIProvider';
import { ReplicateProvider } from './providers/ReplicateProvider';
import { TogetherAIProvider } from './providers/TogetherAIProvider';

class AIProviderManager {
  private providers: Map<AIProviderType, BaseAIProvider> = new Map();
  private credentials: Map<AIProviderType, string> = new Map();
  private defaultProvider: AIProviderType = 'google-gemini';

  constructor() {
    this.initializeProviders();
    this.loadStoredCredentials();
  }

  private initializeProviders(): void {
    this.providers.set('google-gemini', new GoogleGeminiProvider());
    this.providers.set('openai-dalle', new OpenAIProvider());
    this.providers.set('stability-ai', new StabilityAIProvider());
    this.providers.set('replicate', new ReplicateProvider());
    this.providers.set('together-ai', new TogetherAIProvider());
  }

  private loadStoredCredentials(): void {
    try {
      const stored = localStorage.getItem('ai-credentials');
      if (stored) {
        const creds = JSON.parse(stored) as ProviderCredentials[];
        creds.forEach(cred => {
          this.setApiKey(cred.provider, cred.apiKey);
        });
      }
    } catch (error) {
      console.warn('Failed to load stored credentials:', error);
    }
  }

  // Public Methods

  getProvider(type: AIProviderType): BaseAIProvider | undefined {
    return this.providers.get(type);
  }

  getAllProviders(): AIProviderConfig[] {
    return Array.from(this.providers.values()).map(p => p.getConfig());
  }

  getConfiguredProviders(): AIProviderConfig[] {
    return Array.from(this.providers.entries())
      .filter(([_, provider]) => provider.isConfigured())
      .map(([_, provider]) => provider.getConfig());
  }

  setApiKey(provider: AIProviderType, apiKey: string): void {
    const p = this.providers.get(provider);
    if (p) {
      p.setApiKey(apiKey);
      this.credentials.set(provider, apiKey);
      this.saveCredentials();
    }
  }

  async validateApiKey(provider: AIProviderType, apiKey: string): Promise<boolean> {
    const p = this.providers.get(provider);
    if (!p) return false;
    return p.validateApiKey(apiKey);
  }

  removeApiKey(provider: AIProviderType): void {
    const p = this.providers.get(provider);
    if (p) {
      p.setApiKey('');
      this.credentials.delete(provider);
      this.saveCredentials();
    }
  }

  private saveCredentials(): void {
    const creds: ProviderCredentials[] = Array.from(this.credentials.entries())
      .map(([provider, apiKey]) => ({ provider, apiKey }));
    
    // Note: In production, use secure storage, not localStorage
    localStorage.setItem('ai-credentials', JSON.stringify(creds));
  }

  setDefaultProvider(provider: AIProviderType): void {
    this.defaultProvider = provider;
    localStorage.setItem('default-ai-provider', provider);
  }

  getDefaultProvider(): AIProviderType {
    return localStorage.getItem('default-ai-provider') as AIProviderType || this.defaultProvider;
  }

  async generate(request: GenerationRequest): Promise<GenerationResponse> {
    const provider = this.providers.get(request.provider);
    
    if (!provider) {
      throw new Error(`Provider ${request.provider} not found`);
    }

    if (!provider.isConfigured()) {
      throw new Error(`Provider ${request.provider} is not configured. Please add API key.`);
    }

    // Route to appropriate method based on mode
    switch (request.mode) {
      case 'inpainting':
        return provider.inpaint(request);
      case 'image-to-image':
        return provider.editImage(request);
      default:
        return provider.generate(request);
    }
  }

  // Helper to try multiple providers
  async generateWithFallback(
    request: GenerationRequest,
    fallbackProviders: AIProviderType[]
  ): Promise<GenerationResponse> {
    const providers = [request.provider, ...fallbackProviders];
    
    for (const providerType of providers) {
      const provider = this.providers.get(providerType);
      if (!provider?.isConfigured()) continue;

      try {
        const result = await this.generate({ ...request, provider: providerType });
        if (result.success) return result;
      } catch (error) {
        console.warn(`Provider ${providerType} failed:`, error);
      }
    }

    throw new Error('All providers failed to generate image');
  }

  // Estimate cost across providers
  estimateCosts(request: GenerationRequest): Record<AIProviderType, number> {
    const costs: Record<string, number> = {};
    
    for (const [type, provider] of this.providers) {
      if (provider.supportsMode(request.mode)) {
        costs[type] = provider.estimateCost(request);
      }
    }

    return costs as Record<AIProviderType, number>;
  }
}

// Singleton instance
export const aiManager = new AIProviderManager();
export default aiManager;
```

### 5ï¸âƒ£ **AI Store (Zustand)**

```typescript
// store/aiStore.ts

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import {
  AIProviderType,
  GenerationRequest,
  GenerationResponse,
  CatholicArtStyle,
} from '../services/ai/types';
import aiManager from '../services/ai/AIProviderManager';

interface GenerationHistoryItem {
  id: string;
  timestamp: number;
  request: GenerationRequest;
  response: GenerationResponse;
}

interface AIState {
  // Provider state
  activeProvider: AIProviderType;
  setActiveProvider: (provider: AIProviderType) => void;
  
  // Generation state
  isGenerating: boolean;
  generationProgress: number;
  currentRequest: GenerationRequest | null;
  
  // Results
  lastResponse: GenerationResponse | null;
  generationHistory: GenerationHistoryItem[];
  
  // Settings
  defaultStyle: CatholicArtStyle;
  autoEnhancePrompt: boolean;
  saveToHistory: boolean;
  
  // Actions
  generate: (request: Omit<GenerationRequest, 'provider'>) => Promise<GenerationResponse>;
  cancelGeneration: () => void;
  clearHistory: () => void;
  updateSettings: (settings: Partial<AIState>) => void;
}

export const useAIStore = create<AIState>()(
  persist(
    (set, get) => ({
      // Initial state
      activeProvider: 'google-gemini',
      isGenerating: false,
      generationProgress: 0,
      currentRequest: null,
      lastResponse: null,
      generationHistory: [],
      defaultStyle: 'renaissance',
      autoEnhancePrompt: true,
      saveToHistory: true,

      setActiveProvider: (provider) => {
        set({ activeProvider: provider });
        aiManager.setDefaultProvider(provider);
      },

      generate: async (partialRequest) => {
        const state = get();
        
        const request: GenerationRequest = {
          ...partialRequest,
          provider: state.activeProvider,
          style: partialRequest.style || state.defaultStyle,
        };

        set({
          isGenerating: true,
          generationProgress: 0,
          currentRequest: request,
        });

        try {
          // Simulate progress
          const progressInterval = setInterval(() => {
            set((s) => ({
              generationProgress: Math.min(s.generationProgress + 10, 90),
            }));
          }, 1000);

          const response = await aiManager.generate(request);

          clearInterval(progressInterval);

          set({
            isGenerating: false,
            generationProgress: 100,
            lastResponse: response,
          });

          // Save to history
          if (state.saveToHistory && response.success) {
            const historyItem: GenerationHistoryItem = {
              id: response.metadata.requestId,
              timestamp: Date.now(),
              request,
              response,
            };

            set((s) => ({
              generationHistory: [historyItem, ...s.generationHistory].slice(0, 50),
            }));
          }

          return response;
        } catch (error) {
          set({
            isGenerating: false,
            generationProgress: 0,
            lastResponse: {
              success: false,
              provider: state.activeProvider,
              model: request.model,
              images: [],
              metadata: {
                requestId: crypto.randomUUID(),
                timestamp: Date.now(),
                duration: 0,
              },
              error: {
                code: 'GENERATION_FAILED',
                message: (error as Error).message,
                retryable: true,
              },
            },
          });
          throw error;
        }
      },

      cancelGeneration: () => {
        // Note: Actual cancellation depends on provider support
        set({
          isGenerating: false,
          generationProgress: 0,
          currentRequest: null,
        });
      },

      clearHistory: () => {
        set({ generationHistory: [] });
      },

      updateSettings: (settings) => {
        set(settings);
      },
    }),
    {
      name: 'saintcanvas-ai-store',
      partialize: (state) => ({
        activeProvider: state.activeProvider,
        generationHistory: state.generationHistory.slice(0, 20),
        defaultStyle: state.defaultStyle,
        autoEnhancePrompt: state.autoEnhancePrompt,
        saveToHistory: state.saveToHistory,
      }),
    }
  )
);
```

---

## ğŸ¨ UI Components

### Provider Selector

```tsx
// components/AI/ProviderSelector.tsx

import React, { useState } from 'react';
import { 
  Sparkles, 
  Check, 
  AlertCircle, 
  Settings,
  ChevronDown,
  Zap,
  DollarSign 
} from 'lucide-react';
import { useAIStore } from '../../store/aiStore';
import aiManager from '../../services/ai/AIProviderManager';
import { AIProviderType, AIProviderConfig } from '../../services/ai/types';

interface ProviderSelectorProps {
  onSettingsClick?: (provider: AIProviderType) => void;
}

const ProviderSelector: React.FC<ProviderSelectorProps> = ({ onSettingsClick }) => {
  const { activeProvider, setActiveProvider } = useAIStore();
  const [isOpen, setIsOpen] = useState(false);
  
  const allProviders = aiManager.getAllProviders();
  const configuredProviders = aiManager.getConfiguredProviders();
  
  const activeConfig = allProviders.find(p => p.id === activeProvider);

  const getProviderIcon = (id: AIProviderType): React.ReactNode => {
    const icons: Record<AIProviderType, React.ReactNode> = {
      'google-gemini': <span className="text-blue-500">G</span>,
      'openai-dalle': <span className="text-green-500">â—¯</span>,
      'stability-ai': <span className="text-purple-500">S</span>,
      'replicate': <span className="text-orange-500">R</span>,
      'together-ai': <span className="text-cyan-500">T</span>,
      'fal-ai': <span className="text-pink-500">F</span>,
      'leonardo-ai': <span className="text-yellow-500">L</span>,
    };
    return icons[id] || <Sparkles className="w-4 h-4" />;
  };

  const isConfigured = (id: AIProviderType): boolean => {
    return configuredProviders.some(p => p.id === id);
  };

  return (
    <div className="relative">
      {/* Trigger Button */}
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="flex items-center gap-2 px-3 py-2 bg-gray-800 rounded-lg 
                   border border-gray-700 hover:border-gray-600 transition-colors"
      >
        <div className="w-6 h-6 flex items-center justify-center rounded bg-gray-700">
          {getProviderIcon(activeProvider)}
        </div>
        <span className="text-sm font-medium">{activeConfig?.name}</span>
        <ChevronDown className={`w-4 h-4 transition-transform ${isOpen ? 'rotate-180' : ''}`} />
      </button>

      {/* Dropdown */}
      {isOpen && (
        <>
          <div 
            className="fixed inset-0 z-40" 
            onClick={() => setIsOpen(false)} 
          />
          <div className="absolute top-full left-0 mt-2 w-80 bg-gray-800 rounded-xl 
                          border border-gray-700 shadow-xl z-50 overflow-hidden">
            <div className="p-3 border-b border-gray-700">
              <h3 className="text-sm font-semibold text-gray-300">Chá»n AI Provider</h3>
              <p className="text-xs text-gray-500 mt-1">
                {configuredProviders.length} / {allProviders.length} Ä‘Ã£ cáº¥u hÃ¬nh
              </p>
            </div>

            <div className="max-h-80 overflow-y-auto">
              {allProviders.map((provider) => (
                <ProviderOption
                  key={provider.id}
                  provider={provider}
                  isActive={activeProvider === provider.id}
                  isConfigured={isConfigured(provider.id)}
                  onSelect={() => {
                    if (isConfigured(provider.id)) {
                      setActiveProvider(provider.id);
                      setIsOpen(false);
                    }
                  }}
                  onSettings={() => onSettingsClick?.(provider.id)}
                  getIcon={getProviderIcon}
                />
              ))}
            </div>

            <div className="p-3 border-t border-gray-700 bg-gray-800/50">
              <p className="text-xs text-gray-500">
                ğŸ’¡ ThÃªm API key trong Settings Ä‘á»ƒ sá»­ dá»¥ng provider
              </p>
            </div>
          </div>
        </>
      )}
    </div>
  );
};

interface ProviderOptionProps {
  provider: AIProviderConfig;
  isActive: boolean;
  isConfigured: boolean;
  onSelect: () => void;
  onSettings: () => void;
  getIcon: (id: AIProviderType) => React.ReactNode;
}

const ProviderOption: React.FC<ProviderOptionProps> = ({
  provider,
  isActive,
  isConfigured,
  onSelect,
  onSettings,
  getIcon,
}) => {
  return (
    <div
      className={`flex items-center gap-3 p-3 cursor-pointer transition-colors
                  ${isActive ? 'bg-amber-500/10' : 'hover:bg-gray-700/50'}
                  ${!isConfigured ? 'opacity-60' : ''}`}
      onClick={onSelect}
    >
      <div className={`w-10 h-10 flex items-center justify-center rounded-lg 
                       ${isActive ? 'bg-amber-500/20' : 'bg-gray-700'}`}>
        {getIcon(provider.id)}
      </div>

      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <span className="font-medium text-sm">{provider.name}</span>
          {isActive && <Check className="w-4 h-4 text-amber-500" />}
          {!isConfigured && (
            <span className="text-xs px-1.5 py-0.5 bg-gray-700 rounded text-gray-400">
              Cáº§n API Key
            </span>
          )}
        </div>
        <p className="text-xs text-gray-500 truncate">{provider.description}</p>
        
        {/* Quick stats */}
        <div className="flex items-center gap-3 mt-1">
          {provider.pricingInfo && (
            <span className="flex items-center gap-1 text-xs text-gray-500">
              <DollarSign className="w-3 h-3" />
              ${provider.pricingInfo.pricePerImage}/áº£nh
            </span>
          )}
          <span className="flex items-center gap-1 text-xs text-gray-500">
            <Zap className="w-3 h-3" />
            {provider.models[0]?.estimatedTime}s
          </span>
        </div>
      </div>

      <button
        onClick={(e) => {
          e.stopPropagation();
          onSettings();
        }}
        className="p-2 hover:bg-gray-600 rounded-lg transition-colors"
      >
        <Settings className="w-4 h-4 text-gray-400" />
      </button>
    </div>
  );
};

export default ProviderSelector;
```

### API Key Manager

```tsx
// components/AI/APIKeyManager.tsx

import React, { useState, useEffect } from 'react';
import { 
  Key, 
  Eye, 
  EyeOff, 
  Check, 
  X, 
  Loader2,
  ExternalLink,
  Trash2 
} from 'lucide-react';
import aiManager from '../../services/ai/AIProviderManager';
import { AIProviderType, AIProviderConfig } from '../../services/ai/types';

interface APIKeyManagerProps {
  provider: AIProviderType;
  onClose: () => void;
}

const APIKeyManager: React.FC<APIKeyManagerProps> = ({ provider, onClose }) => {
  const [apiKey, setApiKey] = useState('');
  const [showKey, setShowKey] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [validationResult, setValidationResult] = useState<boolean | null>(null);
  const [isSaved, setIsSaved] = useState(false);

  const config = aiManager.getAllProviders().find(p => p.id === provider);
  const isConfigured = aiManager.getConfiguredProviders().some(p => p.id === provider);

  useEffect(() => {
    // Check if already configured
    setIsSaved(isConfigured);
    if (isConfigured) {
      setApiKey('â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢');
    }
  }, [isConfigured]);

  const handleValidate = async () => {
    if (!apiKey || apiKey.includes('â€¢')) return;

    setIsValidating(true);
    setValidationResult(null);

    try {
      const isValid = await aiManager.validateApiKey(provider, apiKey);
      setValidationResult(isValid);
      
      if (isValid) {
        aiManager.setApiKey(provider, apiKey);
        setIsSaved(true);
      }
    } catch (error) {
      setValidationResult(false);
    } finally {
      setIsValidating(false);
    }
  };

  const handleRemove = () => {
    aiManager.removeApiKey(provider);
    setApiKey('');
    setIsSaved(false);
    setValidationResult(null);
  };

  const getProviderGuide = (): { url: string; steps: string[] } => {
    const guides: Record<AIProviderType, { url: string; steps: string[] }> = {
      'google-gemini': {
        url: 'https://aistudio.google.com/app/apikey',
        steps: [
          'Truy cáº­p Google AI Studio',
          'ÄÄƒng nháº­p vá»›i tÃ i khoáº£n Google',
          'Click "Get API Key" > "Create API Key"',
          'Copy key vÃ  dÃ¡n vÃ o Ä‘Ã¢y',
        ],
      },
      'openai-dalle': {
        url: 'https://platform.openai.com/api-keys',
        steps: [
          'Truy cáº­p OpenAI Platform',
          'ÄÄƒng nháº­p hoáº·c táº¡o tÃ i khoáº£n',
          'VÃ o API Keys > Create new secret key',
          'Copy key (chá»‰ hiá»ƒn thá»‹ 1 láº§n)',
        ],
      },
      'stability-ai': {
        url: 'https://platform.stability.ai/account/keys',
        steps: [
          'Truy cáº­p Stability AI Platform',
          'Táº¡o tÃ i khoáº£n vÃ  xÃ¡c thá»±c email',
          'VÃ o Account > API Keys',
          'Create API Key',
        ],
      },
      'replicate': {
        url: 'https://replicate.com/account/api-tokens',
        steps: [
          'Truy cáº­p Replicate',
          'ÄÄƒng nháº­p vá»›i GitHub',
          'VÃ o Account > API Tokens',
          'Create token',
        ],
      },
      'together-ai': {
        url: 'https://api.together.xyz/settings/api-keys',
        steps: [
          'Truy cáº­p Together AI',
          'Táº¡o tÃ i khoáº£n (cÃ³ $25 free credits)',
          'VÃ o Settings > API Keys',
          'Create API Key',
        ],
      },
      'fal-ai': {
        url: 'https://fal.ai/dashboard/keys',
        steps: [
          'Truy cáº­p Fal.ai',
          'ÄÄƒng nháº­p',
          'Dashboard > Keys',
          'Create Key',
        ],
      },
      'leonardo-ai': {
        url: 'https://app.leonardo.ai/api',
        steps: [
          'Truy cáº­p Leonardo AI',
          'ÄÄƒng kÃ½ tÃ i khoáº£n',
          'Settings > API Access',
          'Generate API Key',
        ],
      },
    };

    return guides[provider] || { url: '', steps: [] };
  };

  const guide = getProviderGuide();

  if (!config) return null;

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-xl w-full max-w-md mx-4 overflow-hidden">
        {/* Header */}
        <div className="p-4 border-b border-gray-700 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 bg-amber-500/20 rounded-lg flex items-center justify-center">
              <Key className="w-5 h-5 text-amber-500" />
            </div>
            <div>
              <h2 className="font-semibold">{config.name}</h2>
              <p className="text-xs text-gray-400">Cáº¥u hÃ¬nh API Key</p>
            </div>
          </div>
          <button onClick={onClose} className="p-2 hover:bg-gray-700 rounded-lg">
            <X className="w-5 h-5" />
          </button>
        </div>

        {/* Content */}
        <div className="p-4 space-y-4">
          {/* API Key Input */}
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">
              API Key
            </label>
            <div className="relative">
              <input
                type={showKey ? 'text' : 'password'}
                value={apiKey}
                onChange={(e) => {
                  setApiKey(e.target.value);
                  setValidationResult(null);
                  setIsSaved(false);
                }}
                placeholder="Nháº­p API key..."
                className="w-full px-4 py-2.5 pr-20 bg-gray-900 border border-gray-700 
                           rounded-lg focus:border-amber-500 focus:outline-none"
              />
              <div className="absolute right-2 top-1/2 -translate-y-1/2 flex items-center gap-1">
                <button
                  onClick={() => setShowKey(!showKey)}
                  className="p-1.5 hover:bg-gray-700 rounded"
                >
                  {showKey ? (
                    <EyeOff className="w-4 h-4 text-gray-400" />
                  ) : (
                    <Eye className="w-4 h-4 text-gray-400" />
                  )}
                </button>
              </div>
            </div>

            {/* Validation Status */}
            {validationResult !== null && (
              <div className={`flex items-center gap-2 mt-2 text-sm
                              ${validationResult ? 'text-green-500' : 'text-red-500'}`}>
                {validationResult ? (
                  <>
                    <Check className="w-4 h-4" />
                    <span>API key há»£p lá»‡!</span>
                  </>
                ) : (
                  <>
                    <X className="w-4 h-4" />
                    <span>API key khÃ´ng há»£p lá»‡</span>
                  </>
                )}
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className="flex gap-2">
            <button
              onClick={handleValidate}
              disabled={!apiKey || apiKey.includes('â€¢') || isValidating}
              className="flex-1 py-2.5 bg-amber-500 hover:bg-amber-600 disabled:bg-gray-700 
                         disabled:text-gray-500 rounded-lg font-medium transition-colors
                         flex items-center justify-center gap-2"
            >
              {isValidating ? (
                <>
                  <Loader2 className="w-4 h-4 animate-spin" />
                  Äang xÃ¡c thá»±c...
                </>
              ) : isSaved ? (
                <>
                  <Check className="w-4 h-4" />
                  ÄÃ£ lÆ°u
                </>
              ) : (
                'XÃ¡c thá»±c & LÆ°u'
              )}
            </button>
            
            {isSaved && (
              <button
                onClick={handleRemove}
                className="px-4 py-2.5 bg-red-500/20 hover:bg-red-500/30 
                           text-red-500 rounded-lg transition-colors"
              >
                <Trash2 className="w-4 h-4" />
              </button>
            )}
          </div>

          {/* Guide */}
          <div className="bg-gray-900/50 rounded-lg p-4">
            <h4 className="text-sm font-medium text-gray-300 mb-2">
              CÃ¡ch láº¥y API Key:
            </h4>
            <ol className="text-xs text-gray-400 space-y-1 list-decimal list-inside">
              {guide.steps.map((step, i) => (
                <li key={i}>{step}</li>
              ))}
            </ol>
            <a
              href={guide.url}
              target="_blank"
              rel="noopener noreferrer"
              className="inline-flex items-center gap-1 mt-3 text-xs text-amber-500 
                         hover:text-amber-400"
            >
              Má»Ÿ trang API Key
              <ExternalLink className="w-3 h-3" />
            </a>
          </div>

          {/* Pricing Info */}
          {config.pricingInfo && (
            <div className="text-xs text-gray-500 flex items-center justify-between">
              <span>GiÃ¡: ${config.pricingInfo.pricePerImage}/áº£nh</span>
              {config.pricingInfo.freeCredits && (
                <span className="text-green-500">
                  Free: ${config.pricingInfo.freeCredits} credits
                </span>
              )}
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default APIKeyManager;
```

### Updated Prompt Panel

```tsx
// components/AI/PromptPanel.tsx (Updated)

import React, { useState } from 'react';
import {
  Sparkles,
  Wand2,
  Image as ImageIcon,
  Loader2,
  ChevronDown,
  Info,
  DollarSign,
} from 'lucide-react';
import { useAIStore } from '../../store/aiStore';
import { useEditorStore } from '../../store/editorStore';
import aiManager from '../../services/ai/AIProviderManager';
import ProviderSelector from './ProviderSelector';
import APIKeyManager from './APIKeyManager';
import { CATHOLIC_ART_STYLES } from '../../services/ai/presets/catholicStyles';
import { 
  AIProviderType, 
  GenerationMode, 
  CatholicArtStyle 
} from '../../services/ai/types';

const PromptPanel: React.FC = () => {
  const {
    activeProvider,
    isGenerating,
    generationProgress,
    generate,
    defaultStyle,
    updateSettings,
  } = useAIStore();

  const { addLayer, getCanvasDataURL } = useEditorStore();

  const [prompt, setPrompt] = useState('');
  const [mode, setMode] = useState<GenerationMode>('text-to-image');
  const [selectedStyle, setSelectedStyle] = useState<CatholicArtStyle>(defaultStyle);
  const [selectedModel, setSelectedModel] = useState<string>('');
  const [showAdvanced, setShowAdvanced] = useState(false);
  const [showAPIKeyModal, setShowAPIKeyModal] = useState<AIProviderType | null>(null);

  // Advanced options
  const [numImages, setNumImages] = useState(1);
  const [negativePrompt, setNegativePrompt] = useState('');
  const [guidanceScale, setGuidanceScale] = useState(7.5);

  const providerConfig = aiManager.getProvider(activeProvider)?.getConfig();
  const availableModels = providerConfig?.models || [];
  const isConfigured = aiManager.getConfiguredProviders().some(p => p.id === activeProvider);

  // Set default model when provider changes
  React.useEffect(() => {
    if (availableModels.length > 0 && !selectedModel) {
      setSelectedModel(availableModels[0].id);
    }
  }, [activeProvider, availableModels]);

  const handleGenerate = async () => {
    if (!prompt.trim() || !isConfigured) return;

    try {
      let sourceImage: string | undefined;
      
      if (mode === 'image-to-image') {
        sourceImage = await getCanvasDataURL();
      }

      const response = await generate({
        model: selectedModel,
        mode,
        prompt: prompt.trim(),
        negativePrompt: negativePrompt.trim() || undefined,
        style: selectedStyle,
        numImages,
        guidanceScale,
        sourceImage,
      });

      if (response.success && response.images.length > 0) {
        // Add generated images as layers
        for (const image of response.images) {
          const imgSrc = image.base64 || image.url;
          if (imgSrc) {
            addLayer({
              type: 'ai-generated',
              name: `AI: ${prompt.slice(0, 20)}...`,
              src: imgSrc,
            });
          }
        }
      }
    } catch (error) {
      console.error('Generation failed:', error);
    }
  };

  const estimatedCost = React.useMemo(() => {
    if (!selectedModel) return 0;
    const model = availableModels.find(m => m.id === selectedModel);
    return (model?.costPerImage || 0) * numImages;
  }, [selectedModel, numImages, availableModels]);

  return (
    <div className="flex flex-col h-full bg-gray-900">
      {/* Header */}
      <div className="p-4 border-b border-gray-800">
        <div className="flex items-center justify-between mb-3">
          <h2 className="text-lg font-semibold flex items-center gap-2">
            <Sparkles className="w-5 h-5 text-amber-500" />
            Divine AI
          </h2>
          <ProviderSelector 
            onSettingsClick={(provider) => setShowAPIKeyModal(provider)} 
          />
        </div>

        {/* Mode Toggle */}
        <div className="flex gap-2">
          <button
            onClick={() => setMode('text-to-image')}
            className={`flex-1 py-2 px-3 rounded-lg text-sm font-medium transition-colors
                       ${mode === 'text-to-image' 
                         ? 'bg-amber-500/20 text-amber-500' 
                         : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}
          >
            <Wand2 className="w-4 h-4 inline mr-2" />
            Táº¡o Má»›i
          </button>
          <button
            onClick={() => setMode('image-to-image')}
            className={`flex-1 py-2 px-3 rounded-lg text-sm font-medium transition-colors
                       ${mode === 'image-to-image' 
                         ? 'bg-amber-500/20 text-amber-500' 
                         : 'bg-gray-800 text-gray-400 hover:bg-gray-700'}`}
          >
            <ImageIcon className="w-4 h-4 inline mr-2" />
            Biáº¿n Äá»•i
          </button>
        </div>
      </div>

      {/* Not Configured Warning */}
      {!isConfigured && (
        <div className="mx-4 mt-4 p-3 bg-amber-500/10 border border-amber-500/30 rounded-lg">
          <p className="text-sm text-amber-500">
            Cáº§n thÃªm API key cho {providerConfig?.name} Ä‘á»ƒ sá»­ dá»¥ng
          </p>
          <button
            onClick={() => setShowAPIKeyModal(activeProvider)}
            className="mt-2 text-sm text-amber-400 hover:text-amber-300 underline"
          >
            ThÃªm API Key â†’
          </button>
        </div>
      )}

      {/* Main Content */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {/* Model Selection */}
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">
            Model
          </label>
          <select
            value={selectedModel}
            onChange={(e) => setSelectedModel(e.target.value)}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg
                       focus:border-amber-500 focus:outline-none"
          >
            {availableModels.map((model) => (
              <option key={model.id} value={model.id}>
                {model.name} {model.costPerImage ? `($${model.costPerImage})` : '(Free)'}
              </option>
            ))}
          </select>
        </div>

        {/* Prompt Input */}
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">
            MÃ´ Táº£ HÃ¬nh áº¢nh
          </label>
          <textarea
            value={prompt}
            onChange={(e) => setPrompt(e.target.value)}
            placeholder={mode === 'text-to-image' 
              ? "MÃ´ táº£ hÃ¬nh áº£nh báº¡n muá»‘n táº¡o...\nVÃ­ dá»¥: Äá»©c Máº¹ Maria vá»›i váº§ng hÃ o quang, phong cÃ¡ch Byzantine"
              : "MÃ´ táº£ cÃ¡ch báº¡n muá»‘n biáº¿n Ä‘á»•i canvas hiá»‡n táº¡i..."}
            rows={4}
            className="w-full px-3 py-2 bg-gray-800 border border-gray-700 rounded-lg
                       focus:border-amber-500 focus:outline-none resize-none"
          />
        </div>

        {/* Style Selection */}
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">
            Phong CÃ¡ch Nghá»‡ Thuáº­t
          </label>
          <div className="grid grid-cols-3 gap-2">
            {CATHOLIC_ART_STYLES.map((style) => (
              <button
                key={style.id}
                onClick={() => setSelectedStyle(style.id)}
                className={`p-2 rounded-lg border transition-all text-xs
                           ${selectedStyle === style.id
                             ? 'border-amber-500 bg-amber-500/10'
                             : 'border-gray-700 hover:border-gray-600'}`}
              >
                <span className="text-lg block mb-1">{style.icon}</span>
                <span className="text-gray-300">{style.name}</span>
              </button>
            ))}
          </div>
        </div>

        {/* Advanced Options */}
        <div>
          <button
            onClick={() => setShowAdvanced(!showAdvanced)}
            className="flex items-center gap-2 text-sm text-gray-400 hover:text-gray-300"
          >
            <ChevronDown className={`w-4 h-4 transition-transform ${showAdvanced ? 'rotate-180' : ''}`} />
            TÃ¹y chá»n nÃ¢ng cao
          </button>

          {showAdvanced && (
            <div className="mt-3 space-y-3 p-3 bg-gray-800/50 rounded-lg">
              {/* Number of Images */}
              <div>
                <label className="flex items-center justify-between text-sm text-gray-400">
                  <span>Sá»‘ lÆ°á»£ng áº£nh</span>
                  <span className="text-gray-300">{numImages}</span>
                </label>
                <input
                  type="range"
                  min="1"
                  max="4"
                  value={numImages}
                  onChange={(e) => setNumImages(parseInt(e.target.value))}
                  className="w-full mt-1"
                />
              </div>

              {/* Guidance Scale */}
              <div>
                <label className="flex items-center justify-between text-sm text-gray-400">
                  <span>Äá»™ tuÃ¢n thá»§ prompt</span>
                  <span className="text-gray-300">{guidanceScale}</span>
                </label>
                <input
                  type="range"
                  min="1"
                  max="20"
                  step="0.5"
                  value={guidanceScale}
                  onChange={(e) => setGuidanceScale(parseFloat(e.target.value))}
                  className="w-full mt-1"
                />
              </div>

              {/* Negative Prompt */}
              <div>
                <label className="block text-sm text-gray-400 mb-1">
                  Negative Prompt
                </label>
                <textarea
                  value={negativePrompt}
                  onChange={(e) => setNegativePrompt(e.target.value)}
                  placeholder="Nhá»¯ng gÃ¬ báº¡n KHÃ”NG muá»‘n trong áº£nh..."
                  rows={2}
                  className="w-full px-3 py-2 bg-gray-900 border border-gray-700 
                             rounded-lg text-sm resize-none"
                />
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Footer - Generate Button */}
      <div className="p-4 border-t border-gray-800">
        {/* Cost Estimate */}
        {estimatedCost > 0 && (
          <div className="flex items-center justify-between mb-3 text-sm">
            <span className="text-gray-400 flex items-center gap-1">
              <DollarSign className="w-4 h-4" />
              Chi phÃ­ Æ°á»›c tÃ­nh
            </span>
            <span className="text-amber-500 font-medium">
              ${estimatedCost.toFixed(3)}
            </span>
          </div>
        )}

        <button
          onClick={handleGenerate}
          disabled={!prompt.trim() || isGenerating || !isConfigured}
          className="w-full py-3 bg-gradient-to-r from-amber-500 to-amber-600 
                     hover:from-amber-600 hover:to-amber-700
                     disabled:from-gray-700 disabled:to-gray-700 disabled:text-gray-500
                     rounded-lg font-semibold transition-all
                     flex items-center justify-center gap-2"
        >
          {isGenerating ? (
            <>
              <Loader2 className="w-5 h-5 animate-spin" />
              Äang táº¡o... {generationProgress}%
            </>
          ) : (
            <>
              <Sparkles className="w-5 h-5" />
              {mode === 'text-to-image' ? 'Táº¡o HÃ¬nh áº¢nh' : 'Biáº¿n Äá»•i Canvas'}
            </>
          )}
        </button>
      </div>

      {/* API Key Modal */}
      {showAPIKeyModal && (
        <APIKeyManager
          provider={showAPIKeyModal}
          onClose={() => setShowAPIKeyModal(null)}
        />
      )}
    </div>
  );
};

export default PromptPanel;
```

---

## ğŸ“Š Timeline PhÃ¡t Triá»ƒn

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         DEVELOPMENT ROADMAP                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Phase 1: Foundation (Week 1-2)                                             â”‚
â”‚  â”œâ”€ [ ] Setup types & interfaces                                            â”‚
â”‚  â”œâ”€ [ ] Create BaseProvider abstract class                                  â”‚
â”‚  â”œâ”€ [ ] Refactor existing Google Gemini to new architecture                 â”‚
â”‚  â”œâ”€ [ ] Implement AIProviderManager                                         â”‚
â”‚  â””â”€ [ ] Create AI store (Zustand)                                           â”‚
â”‚                                                                             â”‚
â”‚  Phase 2: Core Providers (Week 3-4)                                         â”‚
â”‚  â”œâ”€ [ ] OpenAI DALL-E Provider                                              â”‚
â”‚  â”œâ”€ [ ] Stability AI Provider                                               â”‚
â”‚  â”œâ”€ [ ] Replicate Provider (Flux)                                           â”‚
â”‚  â”œâ”€ [ ] Together AI Provider                                                â”‚
â”‚  â””â”€ [ ] Unit tests for each provider                                        â”‚
â”‚                                                                             â”‚
â”‚  Phase 3: UI Components (Week 5-6)                                          â”‚
â”‚  â”œâ”€ [ ] ProviderSelector component                                          â”‚
â”‚  â”œâ”€ [ ] APIKeyManager component                                             â”‚
â”‚  â”œâ”€ [ ] Update PromptPanel                                                  â”‚
â”‚  â”œâ”€ [ ] Cost estimator                                                      â”‚
â”‚  â””â”€ [ ] Generation history UI                                               â”‚
â”‚                                                                             â”‚
â”‚  Phase 4: Advanced Features (Week 7-8)                                      â”‚
â”‚  â”œâ”€ [ ] Inpainting support                                                  â”‚
â”‚  â”œâ”€ [ ] Outpainting support                                                 â”‚
â”‚  â”œâ”€ [ ] Provider fallback system                                            â”‚
â”‚  â”œâ”€ [ ] Rate limiting & queue                                               â”‚
â”‚  â””â”€ [ ] Caching generated images                                            â”‚
â”‚                                                                             â”‚
â”‚  Phase 5: Polish & Launch (Week 9-10)                                       â”‚
â”‚  â”œâ”€ [ ] Error handling & retry logic                                        â”‚
â”‚  â”œâ”€ [ ] Loading states & progress                                           â”‚
â”‚  â”œâ”€ [ ] Documentation                                                       â”‚
â”‚  â”œâ”€ [ ] Performance optimization                                            â”‚
â”‚  â””â”€ [ ] User testing & feedback                                             â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## âœ… Checklist TÃ­ch Há»£p

### Foundation
- [ ] Táº¡o types & interfaces cho multi-provider
- [ ] Refactor Google Gemini sang BaseProvider pattern
- [ ] Implement AIProviderManager singleton
- [ ] Setup AI-specific Zustand store
- [ ] Secure credential storage (encrypt API keys)

### Providers
- [ ] Google Gemini (refactor existing)
- [ ] OpenAI DALL-E 3 & GPT-4o
- [ ] Stability AI (SD3, SDXL)
- [ ] Replicate (Flux models)
- [ ] Together AI
- [ ] Fal.ai (optional)
- [ ] Leonardo AI (optional)

### UI/UX
- [ ] Provider selector dropdown
- [ ] API key management modal
- [ ] Per-provider model selector
- [ ] Cost estimation display
- [ ] Generation progress bar
- [ ] Error messages & retry buttons
- [ ] Generation history panel

### Advanced
- [ ] Inpainting with mask editor
- [ ] Image-to-image strength control
- [ ] Batch generation queue
- [ ] Provider health monitoring
- [ ] Automatic fallback on failure
- [ ] Usage analytics

---
